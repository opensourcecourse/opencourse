{
  "hash": "a1029c00ebe73dccd50a755fd0da0d9e",
  "result": {
    "markdown": "---\ntitle: \"Object Oriented Python\"\nsubtitle: OO programming with python\nformat:\n    revealjs:\n        slide-number: true\n        preview-links: auto\n        theme: [../../custom_slides.scss]\n        css: ../../slides.css\n        navigation-mode: vertical\n        controls-layout: bottom-right\n        controls-tutorial: true\nfooter: \\\n    <a href=\"https://opensourcecourse.dev/modules/object_oriented_python/overview.html\">overview</a> /\\\n    <a href=\"https://github.com/opensourcecourse/opencourse/blob/main/modules/object_oriented_python/slides.qmd\">source</a> /\\\n    <a href=\"https://opensourcecourse.dev/modules/object_oriented_python/exercises.html\">exercises</a>\n---\n\n# Intro\n\n<br>\n\nWhat is object oriented programming anyway?\n\n::: {.incremental}\n* An abstraction with Data (attributes) and behavior (methods)\n* Data model may fit real-world\n* Extensibility through inheritance\n:::\n\n\n\n# Intro\n\n<br>\n\n:::{.callout-warning}\nObject Orientied is not synonymous with \"better\"\n:::\n\n\n# Intro\n\n<br>\n\n```python\nclass Dog:\n    def __init__(self, name):\n        self.name = name  # data\n    \n    def say_hello(self):  # behavior\n        print(self.name) \n\n        \nfido = Dog('fido')\nfido.say_hello()\n```\n\n\n\n# Knowledge Check\n\n<br>\n\n```python\nrover = Dog('rover')\n\nrover.say_hello()  # what does this print?\n```\n\n\n\n# Intro\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\nPossible [Advantages]{.blue}\n\n::: {.incremental}\n- Expressive (inuitive interfaces)\n- Modularity (inheretence)\n- Common Paradigm (java/c++)\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\nPossible [Disadvantages]{.red}\n\n::: {.incremental}\n- Expressive (sometimes too much freedom)\n- Shared State (who changed what and when?)\n- Slower Execution (objects vs arrays)\n:::\n\n:::\n\n::::\n\n:::{.fragment}\nOthers?\n:::\n\n# Nomenclature\n\n<br>\n\n::: {.incremental}\n\n- class - the definition (blank form)  \n- instance - the filled in data (filled in form)\n- self - conventional name for instance\n- attribute - data accessed via getattr (object.name)\n- method - class functions (starts with self)\n\n:::\n\n\n\n# Knowledge Check {auto-animate=\"true\"}\n<br>\n\n```{.python}\nclass Customer:\n    name = None\n    \n    def __init__(self, name):\n        self.name = name\n        self.balance = 0\n        \n    def withdraw(self, amount):\n        self.balance -= amount\n```\n\n\n\n# Knowledge Check {auto-animate=\"true\"}\n\n<br>\n\n```{.python code-line-numbers=\"1|2|3|4\"}\nbob = Customer('bob')  # What is bob?  \ncust = Customer  # what is cust?\nbob.balance  # what is balance (value and thing)\nbob.withdraw  # what is withdraw? \n```\n\n\n\n# Dunders\n\n<br>\n\nDunders: things with double leading and trailing underscores. \nThese are part of the python language.\n\n\n\n# Dunders: Examples\n\n<br>\n\n```python\nif __name__ == \"__main__\":\n    ...\n```\n\n\n\n# Dunders: Examples\n\n<br>\n\n```python\nclass Customer:\n    def __init__(self, name):\n        self.name = name\n        self.balance = 0\n```\n\n\n\n# Dunders: Examples\n\n<br>\n\n```python\nclass Customer:\n    def __add__(self, object_2):\n        ...\n```\n\n\n\n# Dunders: Operator overloading\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n- \\__add__\\  (+)\n- \\__sub__\\  (-)\n- \\__mul__\\  (*)\n- \\__truediv__\\  (/)\n- \\__floordiv__\\  (//)\n- \\__pow__\\  (**)\n- \\__rshift__\\  (>>)\n- \\__lshift__\\  (<<)\n\n\n:::\n\n::: {.column width=\"50%\"}\n- \\__or__\\  (|)\n- \\__eq__\\ (==)\n- \\__ne__\\ (!=)\n- \\__gt__\\  (>)\n- \\__lt__\\  (<)\n- \\__neg__\\ (-)\n- \\__pos__\\ (+)\n- \\__invert__\\ (~)\n:::\n\n::::\n\n\n# Dunders: Operator overloading\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass FunkyString:\n    def __init__(self, starting_string):\n        self._data = starting_string\n\n    def __rshift__(self, num):\n        return ' '*num + self._data\n\nfs = FunkyString('bob')\nprint(fs >> 3)\nprint(fs >> 6)\nprint(fs >> 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   bob\n      bob\n         bob\n```\n:::\n:::\n\n\n# Inheritance \n\n<br>\n\n- Inheritance is used to extend or modify classes\n\n- MRO defines lookups (instance) -> (class) -> (parent)\n\n\n\n## Inheritance \n\nYou can check the MRO via the `__MRO__` dunder class attribute.\n\n<br>\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\n\nprint(pd.DataFrame.__mro__)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(<class 'pandas.core.frame.DataFrame'>, <class 'pandas.core.generic.NDFrame'>, <class 'pandas.core.base.PandasObject'>, <class 'pandas.core.accessor.DirNamesMixin'>, <class 'pandas.core.indexing.IndexingMixin'>, <class 'pandas.core.arraylike.OpsMixin'>, <class 'object'>)\n```\n:::\n:::\n\n\n# Inheritance \n\n```{.python code-line-numbers=\"|11|12|13\"}\nclass Parent:\n    value_1 = 0\n    \nclass Child(Parent):\n    value_2 = 1    \n    \n    def __init__(self):\n        self.value_1 = 2\n\nchild = Child()\nprint(child.value_1)\nprint(child.value_2)\nprint(Child.value_1)\n```\n\n\n\n# isinstance and issubclass\n\nChecking class relations is done with `isinstance` and `issubclass`\n```{.python code-line-numbers=\"|7|8|9|10|11|12\"}\nclass Parent():\n    pass\n\nclass Child(Parent):\n    pass\n\nchild = Child()\nisinstance(child, Child)\nisinstance(child, Parent)\nisinstance(Child, Parent)\nissubclass(Child, Parent)\nissubclass(child, Parent)\n```\n\n\n\n# Protocols\n\n<br>\n\nProtocols (sometimes called interfaces):\n\n    - indicate objects are compatible in some way\n    - dunders often used to *implement* protocols\n    - any number of protocols are possible\n\n\n# Protocols\n\nCommon Protocols (most found in types or typing module):\n\n    - Sequence\n    - Mapping\n    - Collection\n    - Hashable\n    - Reversible\n    - Sized\n    - Iterable\n    - ...\n\n\n\n# Protocols\n\nCreate a class which implements the Hashable protocol\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nclass MyHashableClass:\n    def __init__(self, seed: int):\n        self.seed = seed\n    \n    def __hash__(self):\n        return hash(self.seed)\n\nmy_instance = MyHashableClass(42)\n\n# my instance is a valid key in a dictionary\nmy_dict = {my_instance: 42}\n```\n:::\n\n\n# Protocols\n\nCreate a class which implements the Callable protocol\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nclass MyCallableClass:\n    secret_number = 42\n    \n    def __call__(self, arg1, arg2):\n        return self.secret_number + arg1 + arg2\n\nmy_instance = MyCallableClass()\n\n# now instances are callable\nmy_instance(-1, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n42\n```\n:::\n:::\n\n\n# Protocols\n\n<br>\nDefining protocols\n\n    - ABC module and typing.Protocol define protocols\n    - Protocol specifies required methods and their signatures\n    - ABCs use inheretence (or registering virtual children)\n    - typing.Protocol is based on structure not inheritance, often used for static type checking\n\n::: footer\n[This](https://jellis18.github.io/post/2022-01-11-abc-vs-protocol/) is a great article on the difference between ABC and\ntyping.Protocol. See [ABC module](https://docs.python.org/3/library/abc.html) and \n[typing.Protocol](https://peps.python.org/pep-0544/) docs for more details.\n:::\n\n\n\n# Protocols\n\nABC example\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport abc\n\nclass DeckABC(abc.ABC):\n    \"\"\"An ABC for a deck of cards.\"\"\"\n    @abc.abstractmethod\n    def shuffle(self):\n        ...\n    \n    @abc.abstractmethod\n    def draw(self):\n        ...\n```\n:::\n\n\n## Protocols\n\nABC use\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfrom random import choice, sample\n\nclass MyDeck(DeckABC):\n    \"\"\"A deck with cards 1-10\"\"\"\n    def __init__(self, cards=None):\n        if cards is None:\n            cards = list(range(1,11))\n        self.cards = cards\n    \n    def shuffle(self):\n        cards = sample(self.cards, len(self.cards))\n        return MyDeck(cards)\n    \n    def draw(self):\n        card = choice(self.cards)\n        self.cards.pop(card)\n        return card\n        \nmydeck = MyDeck()\n```\n:::\n\n\n# Protocols\n\ntyping.Protocol example\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom typing import Protocol, runtime_checkable, Self\n\n@runtime_checkable\nclass DeckProtocol(Protocol):\n    \"\"\"An ABC for a deck of cards.\"\"\"\n    def shuffle(self) -> Self:\n        ...\n    \n    def draw(self) -> str:\n        ...\n```\n:::\n\n\n## Protocols\n\ntyping.Protocol use\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom typing import Self\nfrom random import choice, sample\n\nclass MyDeck:\n    \"\"\"A deck with cards 1-10\"\"\"\n    def __init__(self, cards=None):\n        if cards is None:\n            cards = list(range(1,11))\n        self.cards = cards\n    \n    def shuffle(self) -> Self:\n        cards = sample(self.cards, len(self.cards))\n        return MyDeck(cards)\n    \n    def draw(self) -> str:\n        card = choice(self.cards)\n        self.cards.pop(card)\n        return card\n\ndeck = MyDeck()\nassert isinstance(deck, DeckProtocol)\n```\n:::\n\n\n# OO Design: Good Examples \n\n<br>\n\nA few well-loved python classes:\n\n:::{.incremental}\n- pathlib.Path\n- pandas.DataFrame\n- scikitlearn (Estimator, Predictor, Transformer, Model)\n- pydantic.BaseModel\n:::\n\n\n\n# OO Design: Good Examples \n\n<br>\n\nbefore pathlib\n```python \nimport os\n\ndata_path = '/home/user/data'\n\ndata_file = os.path.join(data_path, 'the_facts.csv')\n```\n\n\n\n## OO Design: Good Examples \n\n<br>\n\nWith pathlib\n```python \nfrom pathlib import Path\n\ndata_path = Path('/home/user/data')  # / will now work on windows!\n\ndata_file = data_path / 'the_facts.csv'\n```\n\n\n\n# OO Design: Not Good Examples \n\n<br>\n\nA few dreaded python OO libraries:\n\n:::{.incremental}\n- PyQT (Too many objects)\n- VTK (Too many objects)\n- Boto3 (dynamic loading objects, huge number of objects, etc.)\n:::\n\n\n\n# Derrick's OO Design Guidelines \n\n:::{.incremental}\n- Common uses shouldn't require more than 3 classes (make a user-friendly code not a puzzle)\n- Classes are simplest when extensions of familiar protocols (ie list-like plus extra bits)\n- Class division at a high data level (DataFrame rather than dict of Series)\n- Take it easy on operator overloading\n- Avoid deep and multiple inheritance\n- Prefer to return new instances rather than modify in place\n- Functions are just fine too!\n:::\n\n",
    "supporting": [
      "slides_files"
    ],
    "filters": [],
    "includes": {}
  }
}