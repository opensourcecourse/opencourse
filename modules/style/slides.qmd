---
title: "Style Matters"
subtitle: "Grokking Pythonic"
execute:
  enabled: true
format:
    revealjs:
        slide-number: true
        preview-links: auto
        theme: [../../custom_slides.scss]
        css: ../../slides.css
        navigation-mode: vertical
        controls-layout: bottom-right
        controls-tutorial: true

footer: \
    <a href="https://opensourcecourse.dev/modules/style/overview.html">overview</a> /\
    <a href="https://github.com/opensourcecourse/opencourse/blob/main/modules/style/slides.qmd">source</a> /\
    <a href="https://opensourcecourse.dev/modules/style/exercises.html">exercises</a>
---

# Overview

:::{.r-stack}
- A Case for Style
- Idiomatic Python
    - Principles: The Zen
    - Guidelines: PEP8
- Anti-patterns and Code Smells
    - Sloppiness
    - Wrong Language
    - Missing Python Features
:::



# A Case For Style

</br>

:::{.fragment}
As long as it works, why does it matter what it looks like?
:::

:::{.fragment}
What does work mean?
:::

:::{.r-stack}

::: incremental
- The inputs produce the expected outputs?
- The code is understandable?
- The code is easy to extend/debug?
- The code is maintainable?
:::

:::



# A Case for Style

:::{.r-stack}
![](images/babel.png){width="600"}
:::


# A Case for Style

</br>

:::{.r-stack}

```{python}
#| echo: false
#| output: true

import matplotlib.pyplot as plt
import numpy as np

with plt.xkcd():
    fig, ax = plt.subplots(1, 1)
    x_vals = np.arange(1, 100)
    y_vals = x_vals ** 1.1
    ax.plot(x_vals, y_vals)
    ax.set_xlabel('People who use the code')
    ax.set_ylabel("How much style matters")
    ax.set_xticks([])
    ax.set_yticks([])

plt.show()
```
:::




# Idiomatic Python

**Pythonic**: a coding style that leverages Python's unique features to write code that is readable and beautiful.

Pythonic code:

::: incremental

- Embodies Python's guiding principles (The Zen of Python)
- Follows community guidelines (PEP 8, PEP 257, black, etc.)
- Makes good use of python's features and libraries
- Is easy to change

:::



## History of The Zen

::: {.columns}

::: {.column width="40%"}
![](images/tim.png)
:::

::: {.column width="60%"}
Tim Peters wrote the Zen of Python, which was officially adopted via a Python Enhancement Proposal
([PEP 20](https://peps.python.org/pep-0020/)) in 2004.

```python
import this
```

Tim also invented [Timsort](https://en.wikipedia.org/wiki/Timsort), a popular sorting algorithm used in many modern languages.
:::

:::



# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 1. Beautiful
Beautiful is better than ugly.
:::


## Beautiful code:

Although beauty is subjective, [this so post](https://softwareengineering.stackexchange.com/a/207932) does a good job
to explain the main attributed of beautiful code, which includes:

- Clarity and Transparency

- Elegance

- Efficiency

- Aesthetics

It can take some time to develop the beautiful python taste. Study professional codes and keep programming.


# The Zen of Python

</br>


:::{.callout-note appearance="simple"}
## 2. Explicit
Explicit is better than implicit.
:::

## Explicit

Explicit code means the abstractions are conistent and clear. 
It doesn't mean everything is spelled out (you don't have to understand bytecode, 
assembly, or semiconductor physics for your code to be explicit). 


# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 3. Simple
Simple is better than complex.\n\nComplex is better than complicated.
:::


## Simple 

Simple means the most direct (shortest lines of code, most readable) is preferred. This means avoiding
complex features when possible (i.e., dictionaries and numpy arrays are better than custom classes 
for simple cases.) However, sometime the correct behavior is complex, so complex code is unavoidable. 
In this case, it can just be keept as simple as possible (for the user).


# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 4. Flat
Flat is better than nested.
:::


## Flat

Highly nested structures are complex, and they often require recursion to effectively navigate. 
This should be avoided when possible. In scientific computing, numpy operations are strongly
preferred over nested for loops, both for efficiency and readability.


# The Zen of Python

</br>

:::{.callout-note appearance="Concise"}
## 5. Sparse
Sparse is better than dense.
:::


## Concise

Sparisity means fewer things. Fewer classes, fewer functions, fewer parametrs. Concise code better than
verbose code. 

:::{.callout-note appearance="Concise"}
"Perfection is achieved, not when there is nothing to add, but when there is nothing left to take away." 

-Antoine de Saint Exupéry
:::



# The Zen of Python

</br>

:::{.callout-note appearance="Readable"}
## 6. Readable
Readability counts.
:::


## Readable

Readility means code is optimizaed not just for a computer to understand, but for a developer to understand.
This means making documentation a first class concern, and keeping the implementation as simple as possible.

:::{.callout-note appearance="minimal"}
Any fool can write code that a computer can understand. 
Good programmers write code that humans can understand. 

– Martin Fowler"
:::


# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 7. Consistent
Special cases aren't special enough to break the rules.
:::


## Consistent

Concistent means abstractions are clear and not full of special expections.



# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 8. Pragmatic
Although practicality beats purity.
:::


## Pragmatic

Pargamatic means prioritizing functionality and usability over more esoteric concerns like
unlikely edge cases.


# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 9. Correct
Errors should never pass silently.\n\n Unless explicitly silenced.
:::


## Correct

Errors should be raised unless the way to deal with them is obvious.


# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 10. Unsurprising
In the face of ambiguity, refuse the temptation to guess.
:::

## Unsurprising

Guessing what a user may want when there are several viable choises is rarely a good idea.
It is much better to be explicit.




# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 11. Intuitive
There should be one-- and preferably only one -- obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
:::



# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 12. Operational
Now is better than never.
:::



# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 13. Flexible
Although never is often better than \*right\* now.
:::



# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 14. Explainable
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
:::



# The Zen of Python

</br>

:::{.callout-note appearance="simple"}
## 15. Organized
Namespaces are one honking great idea -- let's do more of those!
:::

## Organized

Coming from MATLab, I found having to import python modules annoying. Why is it `np.pi` rather than just `pi`?
Then, I created a variable named `pi` in a matlab finite element code which, of course, overwrote the 
expected value. It took me several hours to debug, but afterward I understood.


# Python Style (Pep 8)

</br>

* Python style-guide adopted in 2001
* Several explicit rules to approach pythonic


## Background

Pep8 is python's style guide. While originally only applicable to the standard library, it is now widely
considered good practice for (nearly) all python projects.

Here we explore a few of the more important aspects of PeP8, but you can find the whole thing [here]


# Pep 8: Line Lengths

</br>

* Limit line lengths to 79 characters
* Limit docstring lengths to 72 characters

:::{.callout-note}
Many modern formatting tools expand the line limit to around 90 characters.
:::




# Style: [Imports](https://peps.python.org/pep-0008/#imports)

</br>

* Each import should be a single line
* Unless multiple things are import *from* the same module

```{.python code-line-numbers="1|2"}
import numpy as np
from pandas import DataFrame, Series
```


# Style: Imports

</br>

* Imports should be organized alphabetically

* Imports should be grouped by
  * module level dunders 
  * standard library 
  * external packages 
  * internal packages



# Style: Imports
</br>

```{.python code-line-numbers="1|3-4|6-7|9"}
from __future__ import annotations

import pathlib
from collections import defaultdict

import numpy as np
import matplotlib.pyplot as plt

from mylibrary.util import combobulate
```



# Style: Naming

</br>

* i (single lowercase letter) - used for incremental variables.
* ALL_CAPITAL - used for constants
* CamelCase - used for classes
* snake_case - used for functions, methods, modules, globals
* Any name starting with _ is considered private


# Style: Naming

</br>

```python
myVariable = 10  # Not for python

my_variable = 10  # correct
```



# Style: Naming

</br>

```python
from PoorlyNamedLibrary import *  # wrong! 

from mylibrary import the_thing_i_need  # better

import mylibrary  # even better (most the time)
```


# Understanding Check

</br>

What's wrong? 

```python
myVar = 10

class snake_class:
    '''A special class for snakes.'''
    __snake_type__ = "python"
    
    def SlitherAround(self):
        ...

```


# Style: Automation

</br> 

* Basic style should be enforced by each project
* Nitpicks are better taken from a bot
* Objective consistency is important


# Style: Automation Tools

</br> 

* black, autopep8, pyflakes, isort, flake8 ...
* All tools can be bundled into [pre-commit](https://pre-commit.com/).
* recommendation: Try [shed](https://github.com/Zac-HD/shed).


# Code Smells and Anti-patterns

</br>

Code smells and anti-patterns: style/design issues in code that works, but isn't
python (elegant, efficient, readable, ...)


# Code Smell: Indents and Lengths

:::{.r-stack}
![](images/code_smell.png)
:::
bbo

# Code Smell: Indents and Lengths







