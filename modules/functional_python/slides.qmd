---
title: "Functional Python"
subtitle: Functionally Educational
format:
    revealjs:
        slide-number: true
        preview-links: auto
        theme: [../../custom_slides.scss]
        css: ../../slides.css
        navigation-mode: vertical
        controls-layout: bottom-right
        controls-tutorial: true

footer: \
    <a href="https://opensourcecourse.dev/modules/functional_python/overview.html">overview</a> /\
    <a href="https://github.com/opensourcecourse/opencourse/blob/main/modules/functional_python/slides.qmd">source</a> /\
    <a href="https://opensourcecourse.dev/modules/functional_python/exercises.html">exercises</a>
---

# Functional Concepts

:::{.incremental}
- Pure functions, immutability, side effects
- Functions as parameters
- Decorators
- Anonymous functions
- Map, reduce
- Recursion
- *Generators
- *Context managers
:::

:::{.footer}
*Not particularly functional but no other place to cover these topics
:::


# Functional Purity {auto-animate="true"}

Define three vector functions

:::{.fragment}

$$
f(a, \vec{x}, \vec{y}) = a \vec{x} + \vec{y}
$$

:::

:::{.fragment}

$$
g(\vec{x}, \vec{y}) = \vec{x} \oslash \vec{y}
$$

:::

:::{.fragment}

$$
h(a, \vec{x}) = \vec{x}^{\circ a}
$$

:::



# Functional Purity {auto-animate="true"}

Does the meaning change with order?

$$
f(a, \vec{x}, \vec{y}) = a \vec{x} + \vec{y}
$$

$$
g(\vec{x}, \vec{y}) = \vec{x} \oslash \vec{y}
$$

$$
h(a, \vec{x}) = \vec{x}^{\circ a}
$$



# Functional Purity {auto-animate="true"}

Does the meaning change with order?

$$
g(\vec{x}, \vec{y}) = \vec{x} \oslash \vec{y}
$$

$$
h(a, \vec{x}) = \vec{x}^{\circ a}
$$

$$
f(a, \vec{x}, \vec{y}) = a \vec{x} + \vec{y}
$$


# Functional Purity {auto-animate="true"}

Does the meaning change with order?

$$
h(a, \vec{x}) = \vec{x}^{\circ a}
$$

$$
f(a, \vec{x}, \vec{y}) = a \vec{x} + \vec{y}
$$

$$
g(\vec{x}, \vec{y}) = \vec{x} \oslash \vec{y}
$$



# Functional Purity {auto-animate="true"}

Does the meaning change with order?

$$
h(a, \vec{x}) = \vec{x}^{\circ a}
$$

$$
g(\vec{x}, \vec{y}) = \vec{x} \oslash \vec{y}
$$

$$
f(a, \vec{x}, \vec{y}) = a \vec{x} + \vec{y}
$$


# Functional Purity {auto-animate="true"}

<br>

```{.python filename="functions"}
def func_f(a, x, y):
    ...

def func_g(x, y):
    ...

def func_h(a, x):
    ...
```


# Functional Purity {auto-animate="true"}

<br>

```{.python filename="inputs"}
import numpy as np

x = np.random.random(10)
y = np.ones_like(x)
a = 12
```


# Functional Purity {auto-animate="true"}

<br>

```{.python filename="Order"}
f_1 = func_f(a, x, y)
g_1 = func_g(x, y)
h_1 = func_h(a, x)

h_2 = func_h(a, x)
g_2 = func_g(x, y)
f_2 = func_f(a, x, y)
```

:::{.fragment}

Do $f_1$ = $f_2$, $g_1$ = $g_2$, $h_1$ = $h_2$ ? 

:::

:::{.fragment}

It depends on [functional purity]{.red-bold} 

:::



# Functional Purity {auto-animate="true"}


```{.python filename="pure functions"}
def func_f(a, x, y):
    out = a * x + y
    return out

def func_g(x, y):
    out = x / y
    return out

def func_h(a, x):
    out = x ** a
    return out
```


# Functional Purity {auto-animate="true"}


```{.python filename="impure functions"}
def func_f(a, x, y):
    x[:] = a * x + y
    return x

def func_g(x, y):
    x[:] = x / y
    return x

def func_h(a, x):
    x[:] = x ** a
    return x
```


# Functional Purity

<br>

```{.python}
global_state = {'value': 1}

def impure_add(a):
    return a + global_state['value']

def pure_add(a):
    return a + 1
```


# Functional Purity {auto-animate="true"}

<br>

:::{.incremental}
- Both pure and impure functions can be **correct**
- Pure functions behave in a mathematically predictable way
- Impure functions cause [side effects]{.red-bold}
- Pure functions are much easier to parallelize
- Pure functions restrict what a programmer can do
:::

  

# Immutability

<br>

```{.python code-line-numbers="|1-2|4|5"}
list_1 = [1, 2, 3]
tuple_1 = (1, 2, 3)

list_1[0] = 0  # sure, why not?
tuple_1[0] = 0  # no way!
```

<br>

:::{.fragment}
Why would we limit ourselves as developers?
:::



# Can Mix OO and Functional Benefits?


```{.python code-line-numbers="|1-3|5-7|9|11-13"}
def double(instance):
    doubled_state = instance.state * 2
    return instance.__class__(doubled_state)

class Class1:
    def __init__(self, state):
        self.state = state

    double = double
  
instance = self(1)
double_instance_1 = self.double()
double_instance_2 = double(instance)
```



# Handling Mutable State 

Safe behavior by default, opt into unsafe behavior

<br>

```{.python code-line-numbers="|1-3|5|7"}
import pandas as pd

df = pd.read_csv('my_csv.csv')

safe = df.sort_values()

not_safe = df.sort_values(in_place=True)
```


# Handling Mutable State 

Mark mutable attributes


```{.python code-line-numbers="|7|9-10"}
from sklearn.cluster import KMeans
import numpy as np

X = np.array([[1, 2], [1, 4], [1, 0],
             [10, 2], [10, 4], [10, 0]])
             
kmeans = KMeans(n_clusters=2).fit(X)

kmeans.labels_
kmeans.cluster_centers_
```


# Immutability

<br>

:::{.incremental}
- Objects cannot change once created
- Side effects related to data are eliminated
- Memory location no longer matters
- New objects are created by functions
- Immutable built-ins: tuple, str, frozenset
- Prefer immutable data, pure functions until otherwise needed
:::


  
# Immutability/Function Purity in the Wild

<br>

:::{.incremental}

- [jax](https://github.com/google/jax)
- [pyrsistent](https://github.com/tobgu/pyrsistent)
- [static-frame](https://github.com/static-frame/static-frame)
- [Apache Arrow](https://arrow.apache.org/)
- [Polars](https://www.pola.rs/)

:::


# Functions as Parameters

<br>

Functions are first class citizens 

:::{.fragment}

```python
def func1():
    print('func1 called')

def func2(func):
    return func()

func2(func1)
```

:::


# Scope

<br>

Scope: the order in which python "sees" names and values (LEGB):

:::{.incremental}
*Local* — callables own indent level

*Enclosing-function* — callable containing callable

*Global* (module) — top-level or module names

*Built-in* (Python) — python names (open, list, set, ValueError, ...)
:::

::: footer
See [here](https://realpython.com/python-scope-legb-rule/) for an excellent overview of scope.
:::



# Scope{auto-animate="true"}

```python
arg = 0

def func_1():
    arg = 1
    
    def func_2():
        arg = 2
        print(arg)
    
    return func_2()

func_1()
```

:::{.fragment}
prints: 2
:::



# Scope{auto-animate="true"}

```python
arg = 0

def func_1():
    arg = 1
    
    def func_2():
        print(arg)
    
    return func_2()

func_1()
```

:::{.fragment}
prints: 1
:::



# Scope{auto-animate="true"}

```python
arg = 0

def func_1():
    
    def func_2():
        print(arg)
    
    return func_2()

func_1()
```

:::{.fragment}
prints: 0
:::


# Scope{auto-animate="true"}

```python
some_arg = 1

def func1():
    print(some_arg)

def func2(func):
    some_arg = 2
    func()

func1()
func2(func1)
```
:::{.fragment}
prints: 1, Why!?
:::



# Scope{auto-animate="true"}

```python
arg = 0

def func_1():
    arg = 1
    
    def func_2():
        global arg
        print(arg)
    
    return func_2()

func_1()
```

:::{.fragment}
prints: 0, why?
:::



# Scope{auto-animate="true"}

```python
arg = 0

def func_1():
    arg = 1
    
    def func_2():
        nonlocal arg
        print(arg)
    
    return func_2()

func_1()
```

:::{.fragment}
prints: 1, why?
:::


:::{.fragment}
The function *definition* determines scope, not its use.
:::



## Scope{auto-animate="true"}

<br>

:::{.callout-note}
most of the time, using `global` or `nonlocal` is not a good idea.
:::



# Decorators (finally){auto-animate="true"}
Decorators are a function that take other function.

```python
def decorator(func):
    def _wrapper(arg1, arg2):
        new_arg1 = arg1 + 1
        new_arg2 = arg2 + 1
        return func(new_arg1, new_arg2)
    return _wrapper

def add(arg1, arg2):
    return arg1 + arg2

add = decorator(add)
print(add(1, 1))
```



# Decorators {auto-animate="true"}
@ is used as syntactic sugar.

```python
def decorator(func):
    def _wrapper(arg1, arg2):
        new_arg1 = arg1 + 1
        new_arg2 = arg2 + 1
        return func(new_arg1, new_arg2)
    return _wrapper

@decorator
def add(arg1, arg2):
    return arg1 + arg2

add(1, 1)
```



# Decorators {auto-animate="true"}
Decorators don't need to replace the old function

```python
registry = []

def decorator(func):
    registry.append(func)
    return func

@decorator
def add(arg1, arg2):
    return arg1 + arg2

print(add(1, 1), len(registry))
```



# Decorators {auto-animate="true"}
Use `wrap` to transfer metedata to new function.

```python
from functools import wraps

def decorator(func):
    @wraps(func)
    def _wrapper(arg1, arg2):
        new_arg1 = arg1 + 1
        new_arg2 = arg2 + 1
        return func(new_arg1, new_arg2)
    return _wrapper
```



# Decorators in the Wild

<br>

functools cache

```python
from functools import cache

@cache
def fibonacci(n):
   if n <= 1:
       return n
   fib1 = fibonacci(n-1)
   fib2 = fibonacci(n-2)
   return fib1 + fib2
```



# Decorators in the Wild

<br>

functools partial

```{python}
#| echo: true
from functools import partial

def add(a, b):
    return a + b

partial_add = partial(add, b=2)

print(partial_add(1))
```



# Decorators in the Wild

<br>

Pytest

```python
import pytest

@pytest.fixture()
def setup_data():
    return [1, 2, 3]

def test_data(setup_data):
    assert len(setup_data)
```



# Decorators in the Wild

<br>

Flask

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!'
```



# Decorators Summary

<br>
Decorators:

:::{.incremental}
- Are functions which take other functions as inputs
- Can use the @ as shorthand for `decorator(func)`
- May return a new function (appears to modify original)
- Semantically mark a function
:::



# Anonymous Functions

:::{.r-stack}
![](https://ih1.redbubble.net/image.789708875.3643/poster,504x498,f8f8f8-pad,600x600,f8f8f8.u4.jpg)
:::



# Anonymous Functions

<br>
Functions with no name

```{.python code-line-numbers="|6"}
my_list = [1, 3, 2]
other_map = {1: 10, 2: 0, 3: 99}

sort_list = sorted(
    my_list, 
    key=lambda x: other_map[x]
)
```



# Anonymous Functions

<br>

Lambda def equivalence

```python
# never give a lambda a name
func1 = lambda x, y, z: x + y + z

# use a def instead
def func1(x, y, z):
    return x + y + z 
```



# Map

<br>

Apply a function to each element of a sequence

```{python}
#| echo: true
my_range = range(10)

# square the list
out = map(lambda x: x*x, my_range)

print(list(out))
```



# Reduce


Apply a function to first two elements, then the result to the third, etc.


```{python}
#| echo: true
from functools import reduce
my_range = range(1, 6)

# square the list
out = reduce(lambda x,y: x*y, my_range)

print(out)
```

::: footer
Haskel calls reduce "fold" which is a more descriptive name.
See [Real Python's article](https://realpython.com/python-reduce-function/) for more on reduce.
:::



# Recursion

<br>
When a function calls into itself. Has a base case and at least one recursive case.


```{.python code-line-numbers="|3|4,5"}
def fibonacci(n):
   if n <= 1:
       return n
   fib1 = fibonacci(n-1)
   fib2 = fibonacci(n-2)
   return fib1 + fib2
```



# Recursion

<br>

Recursion:

:::{.incremental}
- Works well for parsing recursive data structures (eg trees)
- Easy to overflow the stack
- Works well for showing off
- Can be difficult to understand
- Should be used sparingly
:::



# Generators

<br>

:::{.incremental}
- A function which suspends and resumes state
- Useful for memory conservation (large or infinite lists)
- Capable of two-way communication (Basis of async)
- Implements the **Iterable** and **Iterators** protocol
:::



# Generators {auto-animate="true"}


```{.python code-line-numbers="15|1-5|7|9-10|12-14"}
def generator():
    val = 0
    while True:
        val += 1
        yield val

iterable_thing = generator()

# no get_item
iterable_thing[0]  # raise TypeError

# but it is iterable
for val in iterable_thing:  
    print(val)
```


# Generators {auto-animate="true"}

<br>

```{.python code-line-numbers="|8|9-11"}
def generator():
    val = 0
    while True:
        val += 1
        yield val

# Iterator
iterator = generator()
val1 = next(iterator)  # 1
val2 = next(iterator)  # 2
val3 = next(iterator)  # 3
# raises StopIteration when exhausted
```


# Yield From
yield from *drives* iteration

```{.python code-line-numbers="|1-3|5-6"
def generator_1(iterable):
    for a in iterable:
        yield a

def generator_2(iterable):
    yield from iterable
```



# Coroutines {auto-animate="true"}

```{.python code-line-numbers="|1-3|5-6|8,3|9,3"}
def generator(value):
    while True:
        value += yield value

# Iterator
iterable = generator(0)

first = next(iterable)
out1 = iterable.send(10)
out2 = iterable.send(5)
out3 = iterable.send(2)
print(first , out1, out2, out3)
```

:::{.fragment}

```{python}
#| echo: false
def generator(value):
    while True:
        value += yield value

# Iterator
iterable = generator(0)

first = next(iterable)

out1 = iterable.send(10)
out2 = iterable.send(5)
out3 = iterable.send(2)
print(first , out1, out2, out3)
```

:::



# Generators

Generators (like) are **everywhere** in python!

```python
my_dict = {1: 1, 2: 2}
items = my_dict.items()  

generator_comp = (x for x in range(10))
```


# Context Mangers

:::{.incremental}
- Associated with the `with` keyword
- Used to manage setup/teardown for different contexts
:::

```{.python code-line-numbers="|1|2-3"}
with open('some_file.txt', 'w') as fi:
    fi.write('my txt')
...
```


# Context Mangers

```{.python code-line-numbers="|1-4|5|6|7|9-10"}
from contextlib import contextmanager

@contextmaanger
def my_open(filename, mode):
    fi = open(filename, mode)
    yield fi
    fi.close()

with my_open('test_file.txt', 'w') as fi:
    fi.write('my txt')
...
```


## Context Mangers

Class context managers are more powerful

```{.python code-line-numbers="|1-4|5|6|7|9-10"}

class MyOpen:
    def __init__(self, path, mode):
        self._path = path
        self._mode = mode
        self._fi = None
        
    def __enter__(self):
        self._fi = open(self._path)
        return self._fi
        
    def __exit__(self, exc_type, exc_value, exc_tb):
        self._fi.close()

with MyOpen('test_file.txt', 'w') as fi:
    fi.write('my txt')
...
```

:::footer
More on that [here](https://realpython.com/python-with-statement/)
:::


